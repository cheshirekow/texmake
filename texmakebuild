#!/usr/bin/perl

use Fcntl;
use Proc::Killfam;  #apt-get libproc-processtable-perl
use File::Path qw(make_path);
use Switch;

if($#ARGV < 1)
{
    print "usage: $0 output.[dvi|pdf|xhtml] source.tex [bibfiles] \n";
    die;
}

if( -e "texmake.cache" )
{
    require "texmake.cache"
}
else
{
    die "[ERROR]   No texmake.cache found $!\n";
}

my $srcfile = $ARGV[1];
my $outfile = $ARGV[0];

my $srcdir;
my $srcjob;
my $srcext;

my $outdir;
my $outjob;
my $outext;

# strip the directory part from the source file path
if($srcfile =~ /^(.+)\/([^\/]+)$/)
{
    $srcdir    = $1;
    $srcfile   = $2;
}
else
{
    $srcdir    = ".";
}

# strip the extension from the source file
if($srcfile =~ /(.+)\.([^\.]+)/)
{
    $srcjob    = $1;
    $srcext    = $2;
    
    print <<END;
[NOTICE]  srcdir:     $srcdir
[NOTICE]  srcfile:    $srcfile
[NOTICE]  srcjob:     $srcjob
[NOTICE]  srcext:     $srcext
END
    
    print "[WARNING] sourcefile $srcfile is not a .tex file\n" 
        unless ($srcext=~/^tex$/i);
}
else
{
    die "[ERROR]   Cannot split $srcfile into job and extension $!\n";
}

# strip the directory part from the output file path
if($outfile =~ /^(.+)\/([^\/]+)$/)
{
    $outdir    = $1;
    $outfile   = $2;
}
else
{
    $outdir    = ".";
}

# strip the extension from the output file
if($outfile =~ /(.+)\.([^\.]+)/)
{
    $outjob    = $1;
    $outext    = $2;
    
    print <<END;
[NOTICE]  outdir:     $outdir
[NOTICE]  outfile:    $outfile
[NOTICE]  outjob:     $outjob
[NOTICE]  outext:     $outext
END
    
}
else
{
    die "[ERROR]   Cannot split $outfile into job and extension $!\n";
}


# based on what file format we're building, determine what the graphics file
# format is, and what conditional we need to set 

my ($fig,$cmd);

if($outext eq "pdf")
{
    $fig = "pdf";
    $cmd = "\\pdfoutputtrue";
}
elsif($outext eq "dvi")
{
    $fig = "eps";
    $cmd = "\\dvioutputtrue";
}
elsif($outext eq "xhtml" || $outext eq "html")
{
    $fig = "png";
    $cmd = "\\xhtmloutputtrue";
}
else
{
    die "[ERROR]   unknown output extension $ext $1\n";
}


# check to make sure the output directory exists
unless( -e $outdir )
{
    print "[NOTICE]  $outdir does not exist attempting to make it\n";
    make_path($outdir) or die "Failed to make $outdir $!\n";
}

# create the root file for this document build
my $rootfile = "$outdir/$outjob\_$outext.tex";

open ROOTFILE, ">$rootfile" or 
    die "Cannot open $rootfile for write $1\n";

print ROOTFILE <<END;
    \\newif\\ifpdfoutput
    \\newif\\ifxhtmloutput
    \\newif\\ifdvioutput
    
    $cmd
    
    \\listfiles
    
    \\input{$srcfile}
END

close ROOTFILE;

print "[NOTICE]  Created rootfile in $rootfile\n";


# pack up the parameters into a hash that we can pass to the submodules
my %params;
$params{'srcdir'} = $srcdir;
$params{'srcjob'} = $srcjob;
$params{'srcext'} = $srcext;
$params{'outdir'} = $outdir;
$params{'outjob'} = $outjob;
$params{'outext'} = $outext;
$params{'root'}   = $rootfile;

if($outext eq "dvi" || $outext eq "pdf")
{
    build_dvipdf(\%params);
}
else
{
    build_xhtml(\%params);
}










sub build_dvipdf
{
    my $hashref = shift;
    my %params  = %$hashref;
    

    # create read/write pipes so that the child process can communicate with
    # the parent process
    pipe(FROMWATCH, TOPARENT)  or die "Failed to open pipe $!\n";  select(TOPARENT);   $| = 1; select(STDOUT);

    my $pid_watch;
    my $pid_build;

    # fork the process once to create the directory watch
    if($pid_watch = fork)
    {
        # this is the parent, process, he doesn't need to own pipes to
        # himself so we close the pipe
        close TOPARENT;
    }
    
    elsif($pid_watch == 0)
    {
        # this is the child process, he doesn't need to own pipes from
        # himself so we close them
        close FROMWATCH;
        
        # call the submodule which starts the directory watcher 
        watch_child($hashref);
        
        # once the submodule completes, we can kill this process
        exit;
    }
    
    else
    {
        # Error
        die "[ERROR]   Failed to fork texmakebuild for directory watcher $!\n";
    }
    
    # wait for signal from watcher before starting to build
    print "[NOTICE]  parent is waiting for child to be ready\n";
    while(<FROMWATCH>)
    {
        chomp;
        print "[NOTICE]  from child: $_\n";
        last if( /start/i );
    }
    print "[NOTICE]  parent got the signal, starting builder\n";
    
    # call the submodule which starts the builder
    my $buildresult = build_dvipdf_child($hashref);
        
    # now that the builder is done we can stop the watcher
    print "[NOTICE]  Killing watcher $pid_watch\n";
    my $result = killfam SIGINT, $pid_watch;
    
    print "[NOTICE]  Successfully passed signal to $result children\n";
    print "[NOTICE]  Waiting for watcher to stop\n";
    waitpid($pid_watch,0);
    
    print "[NOTICE]  Process tree has been killed\n";
    
    build_dvipdf_clean($hashref);
    
    switch ($buildresult)
    {
        case -1
        {
            print "[ERROR]   Latex failed, check error log\n"
        }
        
        case 1
        {
            print "[NOTICE]  recursing on make\n";
            system ("make " . $ARGV[0] );
        }
        
        case 0
        {
            print "[NOTICE]  done\n";            
        }
    }

}




sub build_dvipdf_clean
{
    my $hashref = shift;
    my %params  = %$hashref;
    
    $srcdir = $params{'srcdir'};
    $outdir = $params{'outdir'};
    $outjob = $params{'outjob'};
    $outext = $params{'outext'};

    my $rootfile    = "$outdir/$outjob\_$outext.tex";
    my $touchfile   = "$outdir/touchlist.txt";    
    my $cleanfile   = "$outdir/clean_$outjob.$outext.d";
    my $cleancache  = "$outdir/clean_$outjob.$outext.cache";
    
    my %outputs;    # output files
    
    # if the cachefile for outputs exists, then load it
    if( -e $cleancache )
    {
        open CACHE, "$cleancache" or die "Failed to open cachefile: $cleancache$!\n";
        while(<CACHE>)
        {
            chomp;
            next if /^\s*$/;    #skip blank lines
            $outputs{$_} = 1;
        }
        close CACHE;
    }
    
    open TOUCH, "$touchfile" or die "Failed to open $touchfile $!\n";
    
    while(<TOUCH>)
    {
        chomp;
        if( /([^,]+),(.+)/ )
        {
            $file   = $1;
            $notify = $2;
            if($notify eq "IN_MODFIY" || $notify eq "IN_CLOSE_WRITE" || $notify eq "IN_CREATE")
            {
                $outputs{$file} = $_;
            }
        }
        else
        {
            print "[WARNING] bad touchfile entry: $_\n";
        }
    }
    
    close TOUCH;
    
    open CLEAN, ">$cleanfile" or die "Failed to open $cleanfile $!\n";
    open CACHE, ">$cleancache" or die "Failed to open $cleancache $!\n";
    
    print CLEAN "clean: \\\n";
    print "[NOTICE]  Touched files\n          ------------------------\n";
    
    foreach my $file (keys %outputs)
    {
        print "             $file " . $outputs{$file} . "\n";
        print CLEAN "    $outdir/$file \\\n";
        print CACHE "$file \n";
    }
    
    print CLEAN <<END;
    $cleanfile \\
    $cleancache \\
    $rootfile \\
    $touchfile

END

    close CLEAN;
    close CACHE;
}




sub build_dvipdf_child
{
    my $hashref = shift;
    my %params  = %$hashref;
    
    $srcdir = $params{'srcdir'};
    $outdir = $params{'outdir'};
    $outjob = $params{'outjob'};
    $outext = $params{'outext'};
    
    my $rootfile    = "$outjob\_$outext.tex";
    my $depfile     = "$outdir/$outjob.$outext.d";
    my $depcache    = "$outdir/$outjob.$outext.cache";
    my $cleanfile   = "$outdir/clean_$outjob.$outext.d";
    my $cleancache  = "$outdir/clean_$outjob.$outext.cache";
    
    my %depends;    # dependencies mapping to their full path
    my %outputs;    # output files
    
    # if the cachefile for depencies exists, then load it
    if( -e $depcache )
    {
        open CACHE, "$depcache" or die "Failed to open cachefile: $depcache$!\n";
        while(<CACHE>)
        {
            chomp;
            if(/([^:\s]+)\s*:\s*([^:\s]+)/)
            {
                $depends{$1} = $2;
            }
            else
            {
                print "[WARNING] bad cachefile entry: $_\n";
            }
        }
        close CACHE;
    }
    

    
    
        
    my $latex="latex";
    if($outext eq "pdf"){ $latex = "pdflatex"; }
    
    my $cmd = <<END;
export TEXINPUTS=".:$outdir:$srcdir:" \\
    && $latex -draftmode -interaction nonstopmode \\
        -output-directory $outdir \\
        $outjob\_$outext.tex 2>&1 |
END

    print "[NOTICE]  Build command: \n";
    print $cmd . "\n";
    
    open BUILD, $cmd;
    
    # set to true when the scanner reaches the file list
    my $filelist=0;
    
    # a list of all missing files
    my @missing;
    
    # a list of all files
    my @filelist;
    
    # scan the output of the builder for the file list and for missing files
    while(<BUILD>)
    {
        chomp;
        if($filelist)
        {
            if(/^\s*\*+\s*$/)
            {
                $filelist=0;
                next;
            }
            elsif(/^\s*(\S+)\s*/)
            {
                push(@filelist,$1);
            }
        }
        else
        {
            if(/^! LaTeX Error: File `([^']+)' not found.$/)
            {
                chomp;
                push(@missing,$1);
                next;        
            }
            elsif(/^\s*\*File List\*\s*$/)
            {
                $filelist=1;
                next;
            }
        }
    }
    
    close BUILD;
    
    my $latexreturn = ${^CHILD_ERROR_NATIVE};
    print "[NOTICE]  Latex status: $latexreturn\n";
    
    print "[NOTICE]  Missing Files:\n          --------------------------\n";
    foreach (@missing)
    {
        print "          $_\n";
    }
    print "\n";
    
    print "[NOTICE]  File List:\n          -------------------------\n";
    foreach (@filelist)
    {
        print "          $_\n";
    }
    
    my (@sty,@cls,@tex,@bib,@fig);
    
    my $arrref=undef;
    my @auxdirs;
    
    my %path;
    my $resolved;
    foreach $ext( 'sty', 'cls', 'tex', 'bib', 'cnf', 'clo', 'def', 'fd')
    {
        $path{$ext} = "$outdir:$srcdir:".`$kpsewhich -progname $latex -show-path .$ext`;
        chomp($path{$ext});
    }
    
    my %ignore;
    foreach $ext( 'cfg', 'mkii', 'out')
    {
        $ignore{$ext} = 1;
    }
    
    my @graphics;
    
    # now open the dependency file to write all dependencies
    open DEPEND, ">$depfile" or die "Failed to open $depfile for writing $!\n";
    open CACHE,  ">$depcache" or die "Failed to open $depcache for writing $!\n";   
    
    print DEPEND "$outdir/$outjob.$outext : \\\n";
    foreach my $file (@filelist)
    {
        if($file=~/(.+)\.([^\.]+)$/)
        {
            my $base    =$1;
            my $ext     =$2;
            
            next if( defined $ignore{$ext} );
            
            if(defined $depends{$file})
            {
                $resolved = $depends{$file};
            }
            else
            {
                print "[NOTICE]  resolving dependency $file\n";
                
                my $path = "$outdir:$srcdir:";
                $path = $path{$ext} if(defined $path{$ext});
                
                $resolved = `$kpsewhich -progname $latex -path $path $file`;
                chomp($resolved);
            }
            
            if(length($resolved) > 0)
            {
                print DEPEND "   $resolved \\\n";
                print CACHE  "$file : $resolved\n";
            }
            else
            {
                print "[WARNING] Failed to find file $file : $resolved\n";
            }
        }
        else
        {
            push (@graphics,$file);
            $resolved = $depends{$file};
            print DEPEND "   $outdir/$file.$fig \\\n";
            print CACHE  "$outdir/$file.$fig : $resolved\n";
        }
    }
    
    my $missinggraphic = 0;
    foreach my $file (@missing)
    {
        if($file=~/(.+)\.([^\.]+)$/)
        {
            print "[WARNING] Dont know how to resolve missing file $file\n";
        }
        else
        {
            $missinggraphic = 1;
            push (@graphics,$file);
            print DEPEND "   $outdir/$file.$fig \\\n";
        }
    }
    
    print DEPEND "\n\n";
    
    foreach my $file (@graphics)
    {
        if($file=~/(.+)\/([^\/]+)/)
        {
            my $dir="$outdir/$1";
            unless (-e $dir)
            {
                print "[NOTICE]  making directory $dir\n";
                make_path($dir) or die "Failed to make directory $dir $!\n";    
            }
        }
        
        my $find = "find $srcdir -path \"*$file.*\"";
        my $found = 0;
        open FIND, "$find |";
        
        while(<FIND>)
        {
            print DEPEND "$outdir/$file.$fig : $_\n\n";
            print CACHE  "$outdir/$file.$fig : $_\n";
            $found = 1;
            last;
        }
        
        print "[WARNING] Failed to find graphics source for $file.$fig\n" unless ($found);
    }
    
    close DEPEND;
    close CACHE;
    

    if($latexreturn && $missinggraphic)
    {
        print "[NOTICE]  Determined that build failed due to missing graphics\n";
        return 1;
    }
    elsif($latexreturn)
    {
        print "[ERROR]   Latex exited with nonzero status and I have no idae why\n";
        return -1;
    }
    else
    {
        return 0;
    }
    
}





sub watch_child
{
    my $hashref = shift;
    my %params  = %$hashref;
    
    setpgrp(0,0);
    
    $outdir = $params{'outdir'};
    print "[NOTIFY]  forked watcher to observe $outdir with $dirwatch\n";
    
    print TOPARENT "start\n";
    exec("$dirwatch $outdir > $outdir/touchlist.txt");
}    
    